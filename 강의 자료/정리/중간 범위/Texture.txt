질감을 갖게 하는 것들은 폴리곤으로 표현 어려움, 그래서 텍스쳐를 사용

텍스쳐 매핑, 텍스쳐링
텍스쳐를 그리는 방법

텍셀
텍스쳐의 픽셀

텍스쳐는 텍셀을 저장하기 위한 구조화된 데이터 집합
한 장의 사진이 아니라 여러 장의 사진들이 구조화된 데이터인 것

텍스쳐를 읽기 위해서는 샘플러가 필요함
텍스쳐는 쉐이더리소스뷰 형태로 파이프라인에 연결

텍스쳐 큐브
6장의 사진을 가진 텍스쳐 배열

밉맵
해상도가 연속적으로 절반인 순서화된 일련의 텍스쳐들
축소하기 위해서는 필터링 알고리즘이 필요
-> 4개의 픽셀의 평균을 내서 하나의 작은 픽셀을 생성
-> 4개의 픽셀을 sort 해서 가운데 색을 픽셀로 생성해도 됨
레벨0: 밉맵의 오리지널 이미지

밉맵을 준비하지 않으면 카메라가 멀어질 경우 축소(계산을 해야 함)가 필요
프레임 레이트 감소
카메라와 모델의 거리에 따라 밉맵의 레벨을 선택한 후 픽셀의 색을 결정하기 위한 알고리즘을 선택
근데 아무튼 모델과 텍스쳐의 개수는 항상 같을 수 없기 떄문에 샘플링이 필요하긴 함
아무튼 효율적
미리 밉맵 레벨을 계산하면 일단 이득이긴 하다는 뜻

LOD(Level Of Detail)
일반적으로 레벨이라고 하는 것은 카메라와 모델의 거리라고 볼 수 있음
카메라까지 거리에 따라 자동적으로 밉맵 레벨 선택
밉맵 레벨의 텍스쳐를 사용하여 텍스쳐 매핑
카메라가 멀리 있으면 모델의 폴리곤이 많아봐야 소용 없음
그래서 카메라의 거리에 따라 폴리곤의 개수 결정
다양한 개수의 폴리곤 개수를 가진 여러 개의 모델 생성
 
스카이박스
2D 사각형 배경 사진

텍스쳐 좌표
100x100 텍스쳐던 50x50 텍스쳐던 0.0 ~ 1.0의 노멀라이즈(정규화)된 좌표계를 사용
-> UV 좌표
텍스쳐의 정점 클래스에는 포지션 좌표와 UV 좌표를 가지고 있어야 함

인덱스를 사용한 큐브에 텍스쳐를 넣을 떄 이미지가 하나밖에 없으면 인덱스는 공유하는 점이 있으므로 Top의 UV 하나의 점이 1 0인 경우 Right에게는 0 0이 되야 하므로 제대로 그려지지 않음
해결방법: 인덱스를 사용하지 않기

샘플링과 필터링
프리미티브를 구성하는 각 픽셀에 대한 과정
1. 각 텍스쳐 좌표에 대한 보간된 텍스쳐 좌표를 계산
2. 텍스쳐 이미지에 대한 픽셀 좌표 계산
3. 텍스쳐 이미지의 픽셀을 반환(어떤 텍셀을 선택하고 어떻게 색상을 계산할 것인가: 필터링)

텍스쳐 압축
시작 색과 끝 색을 넣고 레벨만 정해서 보간 하면 메모리 절약 가능

블럭 압축(BC로 시작하는 놈들)
오리지널 텍스쳐를 손실하는 손실 압축 방법임(Lossy Compression)
그러나 메모리 효율은 8배 이득
압축 해제는 CPU가 아닌 GPU에서 함(색이 필요할 때)
텍스쳐를 4x4 텍셀 블럭으로 분할
각 텍셀은 2비트로 표현(저장): 0~3 인덱스
00: 최소 색 / 01: 최대 색 / 10, 11: 2/3과 1/3
각 블럭은 2개의 색상을 가짐
선형보간으로 계산
오리지널 이미지를 저장하기 위한 메모리: 256바이트
각각의 색을 표현하기 위해서는 4바이트 필요
1개의 블럭은 4 + 16 * 2 = 36바이트

압축 방법에는 여러 방법이 있음
ex) BC1은 A값이 1(투명이냐 반투명이냐), BC2는 A값이 4비트, BC3는 A값이 8비트

DDS 포멧
밉맵, 블럭 압축, 배열을 저장하고 파일을 불러올 수 있음
GPU한테 보내면 GPU가 DDS를 이해하고 있기 때문에 압축 해제는 GPU에서 일어남
VS에서 DDS 파일로 저장을 한 후에 밉맵을 확인하거나 블럭 압축을 하거나 가능함
반드시 블럭 압축을 해야 하는 것은 아님

텍스쳐를 사용하려면 SRV에 넣어서 루트 시그니쳐에 연결을 해야 하는데, 그러려면 먼저 텍스쳐를 리소스로 만들어야 함
이제 JPG나 PNG나 이런 애들은 다 WIC라고 부름

DDS와 WIC의 차이점
DDS는 밉맵이 존재
DDS는 배열이 필요할 경우 사용 가능

서브리소스
텍스쳐 리소스의 부분 집합(배열)
구분하기 위해 인덱스를 사용
서브리소스 인덱스 = 밉슬라이스 + (배열슬라이스 * 밉레벨)

텍스쳐는 쉐이더 리소스 뷰(SRV)로 만들어야 함

SRV DIMENSION
ARRAY: 배열
MS: 멀티 샘플링
TEXTURE2D: 사진 한 장

/////////////////////////////////////////////////////////////////////////
헬리콥터
장애물을 뚫고 안지나가고 부딛히지도 않게 하려면
광선 하나만 쏴서 해결되지는 않음
광선 4개 쏴야 됨
그럼 즉, 직육면체 하나 쏘는거랑 같음
뒤에서 충돌에 관련된 세부 내용을 다루게 됨
과제로 장애물을 충돌하지 않게 하도록 과제가 나갈 것(+텍스쳐 매핑)
/////////////////////////////////////////////////////////////////////////

텍스쳐를 여러 개 사용하기 위해선 배열의 개념 사용
CTEXTURE라는 클래스 생성
CMaterial 안에 쉐이더와 텍스쳐를 넣고
게임 오브젝트는 그 머터리얼을 가지고 있는 형태
텍스쳐는 서술자 테이블로만 넘겨야 함
오브젝트의 텍스쳐가 바뀔 일이 있으면 원래 있는 SRV에 새로운 텍스쳐를 입히는 방식이 아닌, SRV를 두 개 만들어서 Set으로 바인딩만 바꿔주면 됨

텍스쳐 필터링
하나 이상의 텍셀을 읽고 결합하여 하나의 색상을 생성하는 과정
픽셀 UV 좌표(실수)로 텍스쳐의 텍셀을 샘플링하는 방법에 영향을 줌
비교 필터링은 샘플링된 각 텍셀을 비교값과 비교함
- 점 필터링
▷ 장: 구현 빠름, 실시간 렌더링 용이
▷ 단: 계단 현상, 픽셀화 현상
- 선형 필터링
▷ 장: 부드러움, 계단 현상 완화
▷ 단: 계산 비용, 세부 정보 손실 가능
- 밉맵 필터링
▷ 장: 계단 현상 크게 감소, 좋은 품질
▷ 단: 추가 메모리 사용, 밉맵 레벨 사이의 전환 지점이 너무 잘보임
- 비등방 필터링
▷ 장: 경사진 표면 높은 품질, 원근감
▷ 단: 개많은 계산 비용, 추가 메모리 사용, 하드웨어 지원 필요(GPU 있어야됨)

확대 축소할 때 어떻게 할건지 필터가 해줌

텍스쳐 어드레스 모드
WRAP: 텍스쳐가 범위를 벗어나면 텍스쳐가 반복됨
CLAMP: 텍스쳐의 가장자리 픽셀이 확장되어 나머지 영역을 채움
BORDER: 텍스쳐의 범위 밖의 영역을 지정된 테두리 색상으로 채움
MIRROR: 텍스쳐가 범위를 벗어나면 텍스쳐가 거울처럼 반사되이 반복

필터링 함수

텍스쳐 배열
배열 형식으로 텍스쳐를 사용할 수 있음
Texture2D gTreeTextures[4] : register(t4); // 여러 개의 디스크립터 사용(4~7)
-> UV 좌표를 사용
Texture2DArray gTreeTextureArray : register(t4); // 한 개의 디스크립터 사용(4번만)
-> UVW좌표 사용(W: 배열의 인덱스)
텍스쳐의 개수가 정해지지 않은 경우 gTxtruers4[] : registerr(t20) // UnBounded Size
-> D3D12_DESCRIPTOR_RANGGE.NumDescriptors = -1 // 크기가 정해지지 않으면 -1로 씀

빌보드
메쉬를 사각형으로 만들고 텍스쳐 이미지를 매핑
사각형이 항상 카메라를 향하도록 처리

스카이 박스
가장 멀리 있는 객체들의 그림
렌더링 오래 걸림(오버드로우)
제일 나중에 그려보자
-> 픽셀이 바뀔 필요가 없는 부분 존재(어떻게 확인? 뎁스 버퍼로 확인)

▶ 후처리(PostProcessing)


































