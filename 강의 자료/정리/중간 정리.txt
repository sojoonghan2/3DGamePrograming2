Texture
▶ 밉맵
해상도가 연속적으로 절반인 순서화된 일련의 텍스쳐들
축소하기 위한 필터링 알고리즘
▷ 4개의 픽셀의 평균을 내서 하나의 작은 픽셀을 생성
▷ 4개의 픽셀을 정렬해서 가운데 색을 픽셀로 생성
레벨0: 밉맵의 오리지널 이미지

▶ 밉맵의 장점
카메라가 멀어진 경우 축소 계산 필요 없음
프레임 레이트 감소
그러나 모델과 텍스쳐의 개수는 항상 같을 수 없기에 샘플링이 필요하긴 함

▶ LOD(레벨 오브 디떼일)
레벨: 카메라와 모델의 거리
카메라까지 거리에 따라 자동적으로 밉맵 레벨 선택
레벨에 따라 폴리곤 개수 결정

▶ 샘플링과 필터링
프리미티브를 구성하는 각 픽셀에 대한 과정
① 각 텍스쳐 좌표에 대한 보간된 텍스쳐 좌표 계산
② 텍스쳐 이미젱 대한 픽셀 좌표 계산
③ 텍스쳐 이미지의 픽셀을 변환(어떤 텍셀을 선택하고 어떻게 색상을 결정?: 필터링)

▶ 블럭 압축
오리지널 텍스쳐를 손실하는 손실 압축 방법
메모리 효율 8배 이득
압축 해제 CPU말고 GPU에서 함(색이 필요할 때)
텍스쳐를 4x4 텍셀 블럭으로 분할, 각 텍셀 2비트로 표현(0~3 인덱스)
00: 최소색, 01: 최대색, 10과 11: 2/3과 1/3
각 블럭은 2개의 색상을 가짐
선형 보간으로 계산
오리지널 이미지를 저장하기 위한 메모리: 256바이트
각 색을 표현하기 위해서는 4바이트 필요
1개의 블럭: 4 + 16 * 2 = 36바이트

▶ DDS WIC 차이점
DDS는 밉맵이 존재
DDS는 배열이 필요한 경우에만 사용 가능

▶ 서브 리소스
텍스쳐 리소스의 부분 집합(배열)
구분하기 위해 인덱스를 사용
서브리소스 인덱스 = 밉슬라이스 + (배열슬라이스 * 밉레벨)

▶ 텍스쳐를 여러 개 사용하기 위해선 배열의 개념 사용
CTEXTURE라는 클래스 생성
CMaterial 안에 쉐이더와 텍스쳐를 넣고
게임 오브젝트는 그 머터리얼을 갖고 있는 형태
텍스쳐는 서술자 테이블로만 넘겨야 함
오브젝트의 텍스쳐가 바뀔 일이 있으면 원래 있는 SRV에 새로운 텍스쳐를 입히는 방식이 아닌,
SRV를 두 개 만들어서 Set으로 바인딩만 바꿔주면 됨

▶ 텍스쳐 필터링
하나 이상의 텍셀을 읽고 결합하여 하나의 색상을 생성하는 과정
▷ 점 필터링
장: 구현 빠름, 실시간 렌더링 용이
단: 계단 현상, 픽셀화 현상
▷ 선형 필터링
장: 부드러움, 계단 현상 완화
단: 계산 비용, 세부 정보 손실 가능
▷ 밉맵 필터링
장: 계단 현상 크게 감소, 좋은 품질
단: 추가 메모리 사용, 밉맵 레벨 사이의 전환 지점이 너무 잘보임
▷ 비등방 필터링
장: 경사진 표면 높은 품질, 원근감
단: 개많은 계산 비용, 추가 메모리 사용, 하드웨어 지원 필요(GPU 있어야됨)

▶ 텍스쳐 어드레스 모드
WRAP: 텍스쳐가 범위를 벗어나면 텍스쳐가 반복됨
CLAMP: 텍스쳐의 가장자리 픽셀이 확장되어 나머지 영역을 채움
BORDER: 텍스쳐의 범위 밖의 영역을 지정된 테두리 색상으로 채움
MIRROR: 텍스쳐가 범위를 벗어나면 텍스쳐가 거울처럼 반사되이 반복

▶ 텍스쳐 배열
배열 형식으로 텍스쳐를 사용할 수 있음
Texture2D gTreeTextures[4] : register(t4); // 여러 개의 디스크립터 사용(4~7)
-> UV 좌표를 사용
Texture2DArray gTreeTextureArray : register(t4); // 한 개의 디스크립터 사용(4번만)
-> UVW좌표 사용(W: 배열의 인덱스)
텍스쳐의 개수가 정해지지 않은 경우 gTxtruers4[] : registerr(t20) // UnBounded Size
-> D3D12_DESCRIPTOR_RANGGE.NumDescriptors = -1 // 크기가 정해지지 않으면 -1로 씀

▶ 후처리
렌더링된 이미지에 대해 추가적으로 시각적 효관 적용
블러링: 이미지를 부드럽게
텍스쳐 렌더링: 이미지에 텍스쳐 입히는 과정
이미지 필터링: 다양한 필터 효과 적용
샘플러 스테이트, 텍스쳐2D를 사용해서 텍스쳐 처리
픽셀 단위로 색상값 계산
UV 좌표를 이용한 텍스쳐 매핑

Deferred Shading(지연 조명)
▶ 스텐실 컬링
① 색상 출력을 비활성화하여 조명 볼륨을 렌더링
② 조명 계산 쉐이더를 사용하여 출력

▶ 지연 쉐이딩
씬과 조명을 분리
화면-좌표계의 쉐이딩 기법(2Pass)
① 쉐이딩을 먼저 수행하지 않고 보이는 픽셀에 대한 조명 처리 데이터를 수집,
   각 표면을 위한 위치 벡터/법선 벡터/재질 등 일련이ㅡ 텍스쳐로 렌더링,
   이런 일련의 텍스쳐를 기하 버퍼라고 함
② 각 픽셀에 대하여 화면 좌표계에서 조명 효과 계산
다중 렌더 타겟: 단일 패스로 G버퍼 속성 출력
씬을 텍스쳐로 렌더링(조명 계산 X)
장: 오브젝트 수에 비례하지 않는 조명 계산 가능
단: G버퍼에 여러 정보를 저장해야 하므로 메모리가 많지 않으면 속도가 느림

▶ 지연 렌더링
① G버퍼를 생성
② 지연 쉐이딩(조명 계산)
③ 추가 이펙트 처리

Normal Mapping
